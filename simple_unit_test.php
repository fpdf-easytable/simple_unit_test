<?php
/*********************************************************************
* Unit test                                                          *
*                                                                    *
* Version: 1.0                                                       *
* Date:    02-11-2018                                                *
* Author:  Dan Machado                                               *
* Require  php 7 or above                                            *
**********************************************************************/
namespace SimpleUnitTest;

ini_set('display_errors', 1);
error_reporting(E_ALL);

abstract class Unit_Test{
	private static $url;
	private static $response=array('Errors'=>array());
	private static $autoload;
	private static $dummies;
	private static $spies;
	private  $_dummies=array();
	private  $_spies=array();
	private  $_autoload=array();
	protected $_meta;
	protected $meta;
	private static function outPut(){
		$response=json_encode(self::$response, JSON_PRESERVE_ZERO_FRACTION);
		ob_clean();
		ob_start();
		header('Content-Type: application/json');
		header('Content-Length: ' . strlen($response));
		print $response;
		ob_end_flush();
	}
	public static function formated_error($error){
		$formated_error='';
		if($error){
			foreach($error as $k=>$v){
				$formated_error.=$k.': ' . $v . ' | ';
			}
		}
		return $formated_error;
	}
	public static function SET_URL($_url=null){
		if(!$_url){
			die("Please set a URL for this project");
		}
		self::$url=$_url;
	}
	public static function Uncaught_Exception($exception){
		$err=$exception->getMessage();
		self::$response['Errors'][]=array(
						'ErrorCode'=>4096,
						'Message'=>$err, 
						'File'=>$exception->getFile(),
						'Line'=>$exception->getLine(),
						'Extra information'=>self::formated_error(error_get_last()),
						);
		self::outPut();
	}
	function __destruct(){
		self::Fatal_Error();
	}
	public static function Fatal_Error(){
		$error=error_get_last();
		if($error!==NULL){
			$error_codes=array(
				1=>"E_ERROR 	1 	A fatal run-time error, that can't be recovered from. The execution of the script is stopped immediately.",
				2=>"E_WARNING 	2 	A run-time warning. It is non-fatal and most errors tend to fall into this category. The execution of the script is not stopped.",
				4=>"E_PARSE 	4 	The compile-time parse error. Parse errors should only be generated by the parser.",
				8=>"E_NOTICE 	8 	A run-time notice indicating that the script encountered something that could possibly an error, although the situation could also occur when running a script normally.",
				16=>"E_CORE_ERROR 	16 	A fatal error that occur during the PHP's engine initial startup. This is like an E_ERROR, except it is generated by the core of PHP.",
				32=>"E_CORE_WARNING 	32 	A non-fatal error that occur during the PHP's engine initial startup. This is like an E_WARNING, except it is generated by the core of PHP.",
				64=>"E_COMPILE_ERROR 	64 	A fatal error that occur while the script was being compiled. This is like an E_ERROR, except it is generated by the Zend Scripting Engine.",
				128=>"E_COMPILE_WARNING 	128 	A non-fatal error occur while the script was being compiled. This is like an E_WARNING, except it is generated by the Zend Scripting Engine.",
				256=>"E_USER_ERROR 	256 	A fatal user-generated error message. This is like an E_ERROR, except it is generated by the PHP code using the function trigger_error() rather than the PHP engine.",
				512=>"E_USER_WARNING 	512 	A non-fatal user-generated warning message. This is like an E_WARNING, except it is generated by the PHP code using the function trigger_error() rather than the PHP engine",
				1024=>"E_USER_NOTICE 	1024 	A user-generated notice message. This is like an E_NOTICE, except it is generated by the PHP code using the function trigger_error() rather than the PHP engine.",
				2048=>"E_STRICT 	2048 	Not strictly an error, but triggered whenever PHP encounters code that could lead to problems or forward incompatibilities",
				4096=>"E_RECOVERABLE_ERROR 	4096 	A catchable fatal error. Although the error was fatal, it did not leave the PHP engine in an unstable state. If the error is not caught by a user defined error handler (see set_error_handler()), the application aborts as it was an E_ERROR.",
				8192=>"E_DEPRECATED 	8192 	A run-time notice indicating that the code will not work in future versions of PHP",
				16384=>"E_USER_DEPRECATED 	16384 	A user-generated warning message. This is like an E_DEPRECATED, except it is generated by the PHP code using the function trigger_error() rather than the PHP engine.",
				32767=>"E_ALL 	32767 	All errors and warnings, except of level E_STRICT prior to PHP 5.4.0."
			);
			if(!headers_sent() && isset($error_codes[$error['type']])) {
				self::$response['Errors'][]=array('ErrorCode'=>$error['type'],'Message'=>self::formated_error($error));			
			}
			else{
				self::$response['Errors'][]=array('ErrorCode'=>'UNKNOWN ERROR','Message'=>self::formated_error($error));
			}
			self::outPut();
		}
	}
	protected static $CURL_OPTIONS=array(
				CURLOPT_URL =>'',
				CURLOPT_RETURNTRANSFER=>true,
				CURLOPT_ENCODING=>"", 
				CURLOPT_TIMEOUT=>30, 
				CURLOPT_POST=>1
			  );
	public static function curly($post, $f){
		$curl_options=self::$CURL_OPTIONS;
		$curl_options[CURLOPT_URL]=self::$url;
		$curl_options[CURLOPT_POSTFIELDS]=$post;
		$ch = curl_init();
		curl_setopt_array($ch, $curl_options);
		$f($ch);
	}
	public function test($method, array $test_data, $assertion=null){
		$post['method']=$method;	
		$post['test_data']=$test_data;
		$post['assertion']=$assertion;
		$post['url']=self::$url;
		$post['object_instance']=&$this->object_instance;
		$post['meta']=$this->_meta;
		$post['dummies']=$this->_dummies;
		$post['autoload']=$this->_autoload;
		$post['spies']=$this->_spies;
		self::curly(array('unit_test'=>1,'data'=>serialize($post)), function($ch){
			$result=array('ResponseCode'=>500,'Message'=>'');
			$raw_response=curl_exec($ch);
			if(curl_errno($ch)==0 ){
				$status_code=curl_getinfo($ch, CURLINFO_HTTP_CODE);
				$response=explode("\r\n\r\n", $raw_response);
				$n=count($response)-1;
				$body=trim($response[$n]);
				if(!$result=@ json_decode($body, true)){
					$result['ResponseCode']=$status_code;
					unset($result['Message']);	
				}
			}
			else {
				$result['ResponseCode']=curl_errno($ch);
				$result['Message']=curl_error($ch);
			}
			curl_close($ch);
			if(isset($result['object_instance'])){
				$this->object_instance=$result['object_instance'];
				unset($result['object_instance']);
			}
			$this->result[]=$result;
		});
	}
	public function __construct(){
		$params=func_get_args();
		$this->_meta=[
					'Class'=>array_shift($params), 
					'Parameters'=>$params,
					];
		$this->meta=$this->_meta;
		$this->meta['Parameters']=implode('|',array_map(function($v){
			if(is_object($v)){
				return get_class($v);
			}
			else{
				return var_export($v, true);
			}
		},$this->_meta['Parameters']));
		$this->meta['Dummies']=null;
		$this->_autoload=[false, false];
		$this->_dummies=[];
		$this->object_instance='';
		$this->_meta['Parameters']=serialize($this->_meta['Parameters']);
		$this->__init();
	}
	public function autoload($autoload, $prepend=false){
		$this->_autoload[0]=$autoload;
		$this->_autoload[1]=(bool)$prepend;
	}
	public function add_dummies($class_name, $methods, $use_namespace=null){
		if(!isset($this->_dummies[$class_name])){
			$this->_dummies[$class_name]=array('methods'=>array());
		}
		if($use_namespace){
			$this->_dummies[$class_name]['use_namespace']=$use_namespace;
		}
		foreach($methods as $k=>$v){
			$this->_dummies[$class_name]['methods'][$k]=$v;
		}
		$this->meta['Dummies']=$this->_dummies;
	}
	public function add_spy(){
		$args=func_get_args();
		$class_name=array_shift($args);
		if(!isset($this->_spies[$class_name])){
			$this->_spies[$class_name]=array();
		}
		$method=array_shift($args);
		$position=array_shift($args);
		if($position!='begin'){
			$position='end';
		}
		$token="{$method}:{$position}";
		$this->_spies[$class_name][$token]=$args;
	}
	private static function evaluation($result, $expected, $assertion=null){
		if(!$assertion){
			if(is_nan($expected)){
				return is_nan($result);
			}
			if(is_infinite($expected)){
				return is_infinite($result);
			}
			return $result==$expected;
		}
		else{
			if($assertion=='==='){
				return $result===$expected;
			}
			if(is_callable($assertion, false)){
				return call_user_func($assertion, $result, $expected);
			}
			else{
				self::$response['Errors'][]=array(
						'ErrorCode'=>4096,
						'Message'=>'Function: ' . $assertion .' not found', 
						);
			}
		}
	}
	private static function naninf($result){
		if(is_infinite($result)){
			return 'INF';
		}
		elseif(is_nan($result)){
			return 'NAN';
		}
		return $result;
	}
	private static function get_type(&$result){
		if(is_object($result)){
			return get_class($result);
		}
		else{
			return var_export($result, true);
		}
	}
	public static function run_test(){
		$input=unserialize($_POST['data']);
		self::$response['Method']=$input['method'];
		self::$response['Tests']=array();
		self::$url=$input['url'];
		self::$autoload=$input['autoload'][0];
		self::$dummies=$input['dummies'];
		self::$spies=$input['spies'];
		try{
			if($input['autoload'][0]){
				if(!spl_autoload_register('self::dummy_loader', $throw=true, $input['autoload'][1])){
					throw new \Exception(var_export(error_get_last(), true)); 
				}
			}
			$reflexion_class= new \ReflectionClass($input['meta']['Class']);	
			if(!$input['object_instance']){
				$instance_class=$reflexion_class->newInstanceArgs(unserialize($input['meta']['Parameters']));
			}
			else{
				$instance_class=unserialize($input['object_instance']);
			}	
			if($reflexion_class->hasMethod($input['method'])){
				$method_test = $reflexion_class->getMethod($input['method']);
				if(!$method_test->isPublic()) {
					$method_test->setAccessible(true);
				}
				$etime=0;
				foreach($input['test_data'] as $data){
					$test=array_shift($data);
					$expected=array_shift($data);
					$mstart = memory_get_usage();
					$etime=microtime(true);
					$msg='';
					$warnings='';
					$result='n/a';
					try{
						$result=$method_test->invokeArgs($instance_class, $data);
						if(self::evaluation($result, $expected, $input['assertion'])){
							$status='Passed';
						}
						else{
							$status='Failed';
						}
						$wrns=error_get_last();
						if($wrns){
							$warnings=self::formated_error($wrns);
						}
					}
					catch(\Exception $e){
						$status='An exception was thrown';
						$msg=$e->getMessage();
					}
					$etime=microtime(true)-$etime;
					$mend = memory_get_usage();
					$mb=sprintf('%.3f',($mend - $mstart) / 1024 / 1024);
					$params=array();
					foreach($data as $par){
						$params[]=gettype($par) . ': '. var_export($par, true);
					}
					self::$response['Tests'][$test]=array(
												'Status'=>$status, 
												'Result'=>self::get_type($result),
												'Expected Value'=>self::get_type($expected),
												'Parameters'=>$params,//$data[0],
												'Elapsed Time'=>sprintf('%.6f',$etime),
												'Memory Usage'=>$mb,
												'Exception'=>$msg,
												'Warnings'=>$warnings,
												);
				}
				self::$response['object_instance']=serialize($instance_class);
			}
			else {
				self::$response['Errors'][]=array('ErrorCode'=>4096,'Message'=>"The {$input['method']} does not exist",);
			}
		}
		catch (\Exception $e){
			self::$response['Errors'][]=array('ErrorCode'=>4096,'Message'=>'Exception: ' . $e->getMessage(),);
		}
		self::outPut();
	}
	public static function dummy_loader($class){
		if(is_callable(self::$autoload, false)){
			if(isset(self::$dummies[$class]) || isset(self::$spies[$class])){
				$result='';
				$post=array(
								'factory'=>1,
								'autoload'=>self::$autoload,
								'class'=>$class,
								
								);
				if(isset(self::$dummies[$class])){
					$post['dummies']=json_encode(self::$dummies[$class]);
				}
				if(isset(self::$spies[$class])){
					$post['spies']=json_encode(self::$spies[$class]);
				}
				self::curly($post, function($ch) use(&$result){
					$raw_response=curl_exec($ch);
					
					if(curl_errno($ch)==0 ){
						$status_code=curl_getinfo($ch, CURLINFO_HTTP_CODE);
						$response=explode("\r\n\r\n", $raw_response);
						$n=count($response)-1;
						$result=json_decode(trim($response[$n]), true);
					}
					curl_close($ch);
				});
				if(count($result[1])){
					self::$response['Errors'][]=$result[1][0];
				}
				else{
					$dummy_class=base64_decode($result[0]);
					eval($dummy_class);
				}
			}
			else{
				call_user_func(self::$autoload, $class);
			}
		}
		else{
			self::$response['Errors'][]=array(
						'ErrorCode'=>4096,
						'Message'=>'Function: ' . self::$autoload .' not found', 
						);
		}
	}
	public static function get_spy($data){
		static $_spies=array();
		if(is_array($data)){
			$_spies=$data;
		}
		else{
			if(isset($_spies[$data])){
				$ck=array_shift($_spies[$data]);
				if(is_callable($ck, false)){	
					$str='';
					foreach($_spies[$data] as $arg){
						$str.='$'.$arg.',';
					}
					$str=trim($str, ',');
					return "Test::spy('{$ck}', " . $str . ");";
				}
				else{
					self::$response['Errors'][]=array(
						'ErrorCode'=>4096,
						'Message'=>'Function: ' . $ck .' not found', 
						);
				}		
			}
			return '';
		}		
	}
	public static function spy(){
		$args=func_get_args();
		$func=array_shift($args);
		return call_user_func_array($func, $args);
	}
	public static function sustitution($func){
		if(is_callable($func, false)){
			return '$args=func_get_args();
					return call_user_func_array(\''.$func .'\', $args);';
		}
		else{
			self::$response['Errors'][]=array(
						'ErrorCode'=>4096,
						'Message'=>'Function: ' . $func .' not found', 
						);
		}
	}
	public static function factory($post_data){		
		if(isset($post_data['dummies'])){
			$post_data['dummies']=json_decode($post_data['dummies'], true);
		}
		else{
			$post_data['dummies']=array();
		}
		if(isset($post_data['spies'])){
			$post_data['spies']=json_decode($post_data['spies'], true);
		}
		else{
			$post_data['spies']=array();
		}
		self::get_spy($post_data['spies']);
		spl_autoload_register($post_data['autoload']);
		$class= new \ReflectionClass($post_data['class']);	
		$dummy_class='';
		$stl=$class->getStartLine()-1;
		$enl=$class->getEndLine()-1;
		$file=$class->getFileName();
		$c = file($file);
		for($i=0; $i<$stl; $i++){
			if(strpos($c[$i], 'namespace')!==false){
				$dummy_class.=$c[$i];
			}
			elseif(strpos($c[$i], 'use ')!==false){
				$dummy_class.=$c[$i];
			}
		}
		$dummy_class.="use SimpleUnitTest\Test;\n";
		$mm=array();
		$mtd_names=array();
		$sp_names=array();
		foreach($class->getMethods() as $method){
			if(isset($post_data['dummies']['methods'][$method->name])){
				$mtd_names[$method->getStartLine()-1]=$method->name;
			}
			$sp_names[$method->getStartLine()-1]=$method->name;
			$mm[]=$method->getStartLine()-1;
			$mm[]=$method->getEndLine()-1;
		}
		sort($mm);
		$k=0;
		for($i=$stl; $i<=$enl; $i++){
			if(!isset($mm[$k]) || $i!=$mm[$k]){
				$dummy_class.=$c[$i];
			}
			else{
				if(isset($mtd_names[$i])){
					$dummy_class.=$c[$i];
					if(strpos($c[$i], '{')===false){
						$dummy_class.="{\n";
					}
					$dummy_class.=self::sustitution($post_data['dummies']['methods'][$mtd_names[$i]])."
					}\n";
					$i=$mm[$k+1];
				}
				else{
					$spm=$sp_names[$mm[$k]];
					$a=true;
					$j=1;
					$dummy_class.=$c[$mm[$k]];
					if(strpos($c[$mm[$k]], '{')===false){
						$dummy_class.="{\n";
						$j++;
					}
					$dummy_class.=self::get_spy("{$spm}:begin") . "\n";
					for($i=$mm[$k]+$j; $i<=$mm[$k+1]; $i++) {
						if($a && (strpos(trim($c[$i]), 'return')===0 || $i==$mm[$k+1])){
							$a=false;
							$dummy_class.=self::get_spy("{$spm}:end") . "\n";
						}
						$dummy_class.=$c[$i];
					}
					$i--;
				}
				$k+=2;
			}
		}
		return $result=json_encode([base64_encode($dummy_class),self::$response['Errors']]);
		return $dummy_class;
	}
	abstract public function print_results();
	abstract protected function __init();
}

//####################################################################

include __DIR__ . '/extend_simpleunittest.php';

//####################################################################

if(count($_POST)){
	if(isset($_POST['unit_test'])){
		register_shutdown_function('SimpleUnitTest\Test::Fatal_Error');
		set_error_handler('SimpleUnitTest\Test::Fatal_Error', E_ALL);
		set_exception_handler('SimpleUnitTest\Test::Uncaught_Exception');
		Test::run_test();
		exit;
	}
	elseif(isset($_POST['factory'])){
		echo Test::factory($_POST);
		exit;
	}
}

include __DIR__ . '/header.html';

?>