<?php
/*********************************************************************
* Unit test                                                          *
*                                                                    *
* Version: 1.0                                                       *
* Date:    02-11-2018                                                *
* Author:  Dan Machado                                               *
* Require  php 7 or above                                            *
**********************************************************************/
namespace SimpleUnitTest;

ini_set('display_errors', 1);
error_reporting(E_ALL);
define('TIMEOUT', 30);

/*
function debugging($str){
	$h=fopen('/tmp/zxzxzxzxz_debugging', 'a');
	fwrite($h, var_export($str, true));
	fwrite($h, "\n###########################################################\n\n");
	fclose($h);
}
/**/

abstract class Unit_Test{
	/*
	static public function debugging($str){
		$h=fopen('/tmp/zxzxzxzxz_debugging', 'a');
		fwrite($h, var_export($str, true));
		fwrite($h, "\n###########################################################\n\n");
		fclose($h);
	}
	/**/

	private static function outPut(){
		$response=json_encode(self::$response, true);
		ob_clean();
		ob_start();
		header('Content-Type: application/json');
		header('Content-Length: ' . strlen($response));
		print $response;
		ob_end_flush();
	}

	public static function formated_error($error){
		$formated_error='';
		if($error){
			foreach($error as $k=>$v){
				$formated_error.=$k.': ' . $v . ' | ';
			}
		}
		return $formated_error;
	}


	public static function SET_URL($_url=null){
		if(!$_url){
			die("Please set a URL for this project");
		}
		self::$url=$_url;
	}

	public static function Uncaught_Exception($exception){
		
		$err=$exception->getMessage();
		//debugging($err);//error_get_last());
		self::$response['Errors'][]=array(
						'ErrorCode'=>4096,
						'Message'=>$err, 
						'File'=>$exception->getFile(),
						'Line'=>$exception->getLine(),
						'Extra information'=>self::formated_error(error_get_last()),
						);
						
		self::outPut();
	}
	
	private static $response=array('Errors'=>array());

	
	function __destruct(){
		//debugging($this->result);
		self::Fatal_Error();
	}

	public static function Fatal_Error(){
		$error=error_get_last();
		if($error!==NULL){
			$error_codes=array(
				1=>"E_ERROR 	1 	A fatal run-time error, that can't be recovered from. The execution of the script is stopped immediately.",
				2=>"E_WARNING 	2 	A run-time warning. It is non-fatal and most errors tend to fall into this category. The execution of the script is not stopped.",
				4=>"E_PARSE 	4 	The compile-time parse error. Parse errors should only be generated by the parser.",
				8=>"E_NOTICE 	8 	A run-time notice indicating that the script encountered something that could possibly an error, although the situation could also occur when running a script normally.",
				16=>"E_CORE_ERROR 	16 	A fatal error that occur during the PHP's engine initial startup. This is like an E_ERROR, except it is generated by the core of PHP.",
				32=>"E_CORE_WARNING 	32 	A non-fatal error that occur during the PHP's engine initial startup. This is like an E_WARNING, except it is generated by the core of PHP.",
				64=>"E_COMPILE_ERROR 	64 	A fatal error that occur while the script was being compiled. This is like an E_ERROR, except it is generated by the Zend Scripting Engine.",
				128=>"E_COMPILE_WARNING 	128 	A non-fatal error occur while the script was being compiled. This is like an E_WARNING, except it is generated by the Zend Scripting Engine.",
				256=>"E_USER_ERROR 	256 	A fatal user-generated error message. This is like an E_ERROR, except it is generated by the PHP code using the function trigger_error() rather than the PHP engine.",
				512=>"E_USER_WARNING 	512 	A non-fatal user-generated warning message. This is like an E_WARNING, except it is generated by the PHP code using the function trigger_error() rather than the PHP engine",
				1024=>"E_USER_NOTICE 	1024 	A user-generated notice message. This is like an E_NOTICE, except it is generated by the PHP code using the function trigger_error() rather than the PHP engine.",
				2048=>"E_STRICT 	2048 	Not strictly an error, but triggered whenever PHP encounters code that could lead to problems or forward incompatibilities",
				4096=>"E_RECOVERABLE_ERROR 	4096 	A catchable fatal error. Although the error was fatal, it did not leave the PHP engine in an unstable state. If the error is not caught by a user defined error handler (see set_error_handler()), the application aborts as it was an E_ERROR.",
				8192=>"E_DEPRECATED 	8192 	A run-time notice indicating that the code will not work in future versions of PHP",
				16384=>"E_USER_DEPRECATED 	16384 	A user-generated warning message. This is like an E_DEPRECATED, except it is generated by the PHP code using the function trigger_error() rather than the PHP engine.",
				32767=>"E_ALL 	32767 	All errors and warnings, except of level E_STRICT prior to PHP 5.4.0."
			);
			if(!headers_sent() && isset($error_codes[$error['type']])) {
				self::$response['Errors'][]=array('ErrorCode'=>$error['type'],'Message'=>self::formated_error($error));			
				//self::$response['Errors'][]=$error;			
			}
			else{
				self::$response['Errors'][]=array('ErrorCode'=>'UNKNOWN ERROR','Message'=>self::formated_error($error));
			}
			
			self::outPut();
		}
		//debugging($error);
	}


	public static function curly($post, $f){
		
		$curl_options=array(
				CURLOPT_URL => self::$url,
				//CURLOPT_FOLLOWLOCATION=>true,
				CURLOPT_RETURNTRANSFER=>true,
				CURLOPT_ENCODING=>"", // to accept all supported encoding types
				CURLOPT_TIMEOUT=>TIMEOUT,  // in seconds
				CURLOPT_POST=>1
			  );

		$ch = curl_init();
		$curl_options[CURLOPT_POSTFIELDS]=$post;
		curl_setopt_array($ch, $curl_options);
		$f($ch);
	}


/*
test(
	$method : string the name of the method to test
	$test_data : array array('Name of the test'=>array(array_of_parameters_of_methods, mixed expected_result)
	$assertion : opt callable_assertion_function_to_be_used_to_assert_result
)

*/

	public function test($method, array $test_data, $assertion=null){
		$this->data['method']=$method;		
		$this->data['test_data']=$test_data;
		$this->data['assertion']=$assertion;
		$this->data['url']=self::$url;
		$this->data['object_instance']=$this->object_instance;
		
		self::curly(array('unit_test'=>1,'data'=>json_encode($this->data)), function($ch){
			$result=array('ResponseCode'=>500,'Message'=>'');
			$raw_response=curl_exec($ch);
		
			if(curl_errno($ch)==0 ){
				$status_code=curl_getinfo($ch, CURLINFO_HTTP_CODE);
				$response=explode("\r\n\r\n", $raw_response);
				$n=count($response)-1;
				$body=trim($response[$n]);
			
				if(!$result=@ json_decode($body, true)){
					$result['ResponseCode']=$status_code;
					unset($result['Message']);	
				}
			}
			else {
				$result['ResponseCode']=curl_errno($ch);
				$result['Message']=curl_error($ch);
			}
		
			curl_close($ch);
			if(isset($result['object_instance'])){
				$this->object_instance=$result['object_instance'];
				unset($result['object_instance']);
			}
			$this->result[]=$result;//['results'];
			//debugging($result);
		});
	}
	
	
	abstract public function print_results();

	private $data;
	private static $url;

/*
new Test(
$class : string the name of the class to test
$set_up : array(
				'constructor_params'=>array(), //
				'autoload'=>'class_loader2', //callable name of the function to be use by autoloader
				'prepend'=>false, // parameter for autoloader
				'dummies'=>array('class_name'=>array('method_name'=>"return_value"))
		
example:
'Demo', array(
				'constructor_params'=>serialize(array()),
				'autoload'=>'class_loader2',
				'prepend'=>false, 
				'dummies'=>array('Helper'=>array('get_name'=>"'Horacio'"))

*/

	public function __construct($class, $set_up){//array $constructor_param, $autoload_function=null,  $prepend=false){
		$this->meta=array('Class'=>$class, 'Parameters'=>'', 'Dummies'=>'');
		try{
			$this->object_instance='';
			$this->data=$set_up;//
			if(!isset($this->data['prepend'])){
				$this->data['prepend']=false;
			}
			if(!isset($this->data['constructor_params'])){
				$this->data['constructor_params']=array();
			}
			if(!is_array($this->data['constructor_params'])){
				$this->data['constructor_params']=array($this->data['constructor_params']);
			}
			foreach($this->data['constructor_params'] as $par){
				$this->meta['Parameters'].=var_export($par, true) . ' | ';
			}
			$this->meta['Parameters']=trim($this->meta['Parameters'],' |');
		
			$this->data['constructor_params']=serialize($this->data['constructor_params']);
			$this->data['class']=$class;
			if(isset($this->data['dummies'])){
				foreach($this->data['dummies'] as $cls=>$mds){
					foreach($mds as $k=>$v){
						$this->data['dummies'][$cls][$k]=$v;//serialize($v);
					}
				}
			}
			else{
				$set_up['dummies']=null;
			}
			$this->meta['Dummies']=$set_up['dummies'];
		}
		catch(\Exception $e)
		{
			
		}
	}

	private static function evaluation($x, $y, $assertion=null){
		if(!$assertion){
			return $x==$y;
		}
		else{
			return call_user_func($assertion, $x, $y);
		}
	}


	public static function run_test(){
		$input=json_decode($_POST['data'], true);
		
		//self::$response['Class']=$input['class'];
		self::$response['Method']=$input['method'];
		self::$response['Tests']=array();
		self::$url=$input['url'];
		if(!isset($input['dummies'])){
			$input['dummies']=array();
		}
		//debugging($input['dummies']);
		try{
			if($input['autoload']){
				self::dummy_loader(null, array($input['autoload'], $input['dummies']));
				if(!spl_autoload_register('self::dummy_loader', $throw=true, $input['prepend'])){
					throw new \Exception(var_export(error_get_last(), true)); 
				}
			}
			
			$reflexion_class= new \ReflectionClass($input['class']);	
			
			if(!$input['object_instance']){
				$instance_class=$reflexion_class->newInstanceArgs(unserialize($input['constructor_params']));
			}
			else{
				$instance_class=unserialize($input['object_instance']);
			}	
			//debugging($input['class']);//error_get_last());

			if($reflexion_class->hasMethod($input['method'])){
					
				$method_test = $reflexion_class->getMethod($input['method']);
				if(!$method_test->isPublic()) {
					$method_test->setAccessible(true);
				}
				//debugging(error_get_last());
				$etime=0;
				foreach($input['test_data'] as $test=>$data){
					///*
					if(!isset($data[0])){
						$data[0]=array();
						$data[1]=null;
					}
					elseif(!is_array($data[0])){
						$data[0]=array($data[0]);
					}
					$mstart = memory_get_usage();
					$etime=microtime(true);

					$msg='';
					$warnings='';
					$result='n/a';
					
					try{
						$result=$method_test->invokeArgs($instance_class, $data[0]);
						if(self::evaluation($result,$data[1], $input['assertion'])){
							$status='Passed';
						}
						else{
							$status='Failed';
						}
						$wrns=error_get_last();
						//debugging($wrns);
						if($wrns){
							$warnings=self::formated_error($wrns);
						}
					}
					catch(\Exception $e){
						$status='An exception was thrown';
						$msg=$e->getMessage();
					}
					/*
					we can add more catch blocks 
					*/
					
					$etime=microtime(true)-$etime;
					$mend = memory_get_usage();
					$mb=sprintf('%.3f',($mend - $mstart) / 1024 / 1024);
					$params='';
					foreach($data[0] as $par){
						$params.=gettype($par) . ': '. var_export($par, true) . ' | ';
					}
					$params=trim($params,' ,|');
					self::$response['Tests'][$test]=array(
												'Status'=>$status, 
												'Result'=>$result,
												'Expected Value'=>$data[1],
												'Parameters'=>$params,//$data[0],
												'Elapsed Time'=>sprintf('%.6f',$etime),
												'Memory Usage'=>$mb,
												'Exception'=>$msg,
												'Warnings'=>$warnings,
												);
				}
				self::$response['object_instance']=serialize($instance_class);
				//debugging(self::$response['object_instance']);
			}
			else {
				self::$response['Errors'][]=array('ErrorCode'=>4096,'Message'=>"The {$input['method']} does not exist",);
			}
		}
		catch (\Exception $e){
			self::$response['Errors'][]=array('ErrorCode'=>4096,'Message'=>'Exception: ' . $e->getMessage(),);
		}
		self::outPut();
	}


	public static function factory($post_data){//$autoload, $class_name, $default_return){
		
		$post_data['dummies']=json_decode($post_data['dummies'], true);	
		spl_autoload_register($post_data['autoload']);
		$class= new \ReflectionClass($post_data['class']);	
		$tmp=explode('\\',$class->name);
		$class_name=$tmp[count($tmp)-1];
		//debugging($class->getNamespaceName());
		$dummy_class='';
		if($class->getNamespaceName()){	
			$dummy_class.='namespace ' . $class->getNamespaceName() . ";\n";
		}
		$stl=$class->getStartLine()-1;
		$enl=$class->getEndLine()-1;
		$file=$class->getFileName();
		$mm=array();
		$mtd_names=array();
		foreach($class->getMethods() as $method){
			if(isset($post_data['dummies'][$method->name])){
				$mtd_names[$method->getStartLine()-1]=$method->name;
			}
			$mm[]=$method->getStartLine()-1;
			$mm[]=$method->getEndLine()-1;
			
		}
		sort($mm);
		$k=0;
	 	$c = file($file);
		for($i=$stl; $i<=$enl; $i++){
			if(!isset($mm[$k]) || $i!=$mm[$k]){
				$dummy_class.=$c[$i];// . "\n";
			}
			else{
				if(isset($mtd_names[$i])){
					$dummy_class.=$c[$i];
					if(strpos($c[$i], '{')===false){
						$dummy_class.='{';
					}
					//$dummy_class.="return unserialize('".$post_data['dummies'][$mtd_names[$i]]."');\n}";
					$dummy_class.=$post_data['dummies'][$mtd_names[$i]].";\n}";
					$i=$mm[$k+1];
				}
				else{
					for($i=$mm[$k]; $i<=$mm[$k+1]; $i++) {
						$dummy_class.=$c[$i] . "";
					}
					$i--;
				}
				$k+=2;
			}
		}
		//debugging($dummy_class);
		return $dummy_class;
	}

	public static function dummy_loader($class, $_data=null){
		static $autoloader='';
		static $dummy_list=array();
		if($_data){
			$autoloader=$_data[0];
			$dummy_list=$_data[1];
		}
		
		if($class!=null){
			if(in_array($class, $dummy_list) || isset($dummy_list[$class])){
				$dummy_class='';
				$post=array(
								'factory'=>1,
								'autoload'=>$autoloader,
								'class'=>$class,
								'dummies'=>json_encode($dummy_list[$class])
								);
							
				self::curly($post, function($ch) use(&$dummy_class){
					$raw_response=curl_exec($ch);
					
					if(curl_errno($ch)==0 ){
						$status_code=curl_getinfo($ch, CURLINFO_HTTP_CODE);
						$response=explode("\r\n\r\n", $raw_response);
						$n=count($response)-1;
						$dummy_class=trim($response[$n]);
					}
					curl_close($ch);
				});
				//debugging($dummy_class);
				eval($dummy_class);
				//debugging(error_get_last());
			}
			else{
				call_user_func($autoloader, $class);
			}
		}
	}

}

//####################################################################
//####################################################################
//####################################################################
//
class Test extends Unit_Test
{
	public function print_results(){
		//debugging();
		include_once 'simple_unit_test_print_results.php';
		return print_results($this->result, $this->meta);
	}
}

//####################################################################
//####################################################################
//

if(count($_POST)){
//use SimpleUnitTest\Test;
	if(isset($_POST['unit_test'])){
	
		register_shutdown_function('SimpleUnitTest\Test::Fatal_Error');//, E_ALL);
		set_error_handler('SimpleUnitTest\Test::Fatal_Error', E_ALL);
		set_exception_handler('SimpleUnitTest\Test::Uncaught_Exception');

		Test::run_test();
	
		exit;
	}
	elseif(isset($_POST['factory'])){
		echo Test::factory($_POST);
		exit;
	}
}

?>